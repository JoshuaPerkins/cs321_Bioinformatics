****************
* Project: Bioinformatics
* Class: CS 321 - Steven Cutchin
* Date: April 13, 2018
* Author: Joshua Perkins (JPerkins)
**************** 

**-- * -- THIS IS A TEMPLATE THAT NEEDS REPLACING -- * --**

OVERVIEW:
 
 A program that simulates CPU scheduling through the use of a priority 
 queue. The queue will be implemented in a max-heap structure that contains 
 processes elements from the CPU scheduler.

INCLUDED FILES:

 * Instructor provided project files:
   +  CPUScheduling.java - source file
   +  Averager.java - source file
 
 * Created project files:
   + MaxHeap.java - source file
   + Process.java - source file
   + ProcessGenerator.java - source file
   + PQueue.java - source file
   + README - this file

PROGRAM DESIGN AND IMPORTANT CONCEPTS:
 
 The MaxHeap class is designed to structure an array list into a max-heap
 data structure. The PQueue class will use MaxHeap to provide this
 functionality. The PQueue class contains the priority queue for the 
 processes that are generated by the CPU Scheduler and contains functionality
 to add and remove processes to and from the queue. The ProcessGenerator
 class is designed to generate simulated CPU processes so that they can 
 be added into the queue. The Process class defines a CPU process and its
 functionality.
 
 The PQueue class hold the array list needed to act as the priority queue.
 This is because the PQueue is intended to act as the queue class and the
 MaxHeap class is a helper class designed to arrange the queue into a max-heap
 data structure for correct processing of the queue. The CPUScheduler class
 contains the main function that will be run by the program and was set up
 by the course instructors.
 
PROGRAM USAGE:

 When running the CPUScheduler class the user must pass in the maximum process
 run time, the maximum process priority level, the time required to pass before
 a process is incremented in priority, the total scheduler simulation time, and 
 the arrival rate of new processes. The user input determines the run time and 
 average number of processes that are simulated during the programs run time.  

 When running the CPUScheduler class the user will specify the process
 characteristics to run the program. After compiling all the java files
 (with javac *.java) the program can be run using the following argument list.

 Command line arguments to run a CPU Scheduler Simulation:
 
 	$java CPUScheduling <maxProcessTime> <maxPriorityLevel> <timeToIncrementPriority> <simulationTime> <processArrivalRate>

 Example (testing example that corresponds to the provided sample_results output):
 	
 	$java CPUScheduling 5 5 5 100 0.4

TESTING:

 The sample_results file was used to compare the generated output to an example
 output. The provided sample can not specifically correlate to the output as the
 number of process generated and the timing of their generation is random by the
 nature of the program. Testing was done looking at the code manually and making
 sure that the queue structure was correct and the generated output followed the 
 priority queue's intended purpose. 
  
 There are no known bugs/issues with the code or project.


 NOTE: With more time a specific test case with a specified array list could be 
 made and tested for better accuracy.  

DISCUSSION:
 
 The random aspects of each processes process time and priority level made the 
 task of testing the simulations functionality more difficult; but by stepping
 through the output based upon the report of when the processes were made and
 finished helped prove the correctness of the program. 
 
 As discussed in class; changing the update function to not use MaxHeapifyUp
 inside of the for loop and instead use a compare method walking from the end 
 of the array list to the beginning saved time. In order to see this I ran the 
 CPU scheduling simulation for 100,000 units of simulation time. Adding a 
 stopwatch (System.currentTimeMillis()) counter to the beginning and end of
 CPUScheduling.java allowed me to measure the total run time of the program. 
 It was seen that comparing the children to the parent at the end of the update
 method, using MaxHeapifyCompare (instead of MaxHeapifyUp inside of the for
 loop) saved an average of 1.2 seconds of runtime over 5 runs of the program.
